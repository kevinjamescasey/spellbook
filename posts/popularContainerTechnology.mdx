


This is meant to provide the trunk and largest branches of the tree of understanding. They can be followed to the twigs, leaves, and fruit.

### Docker

Docker is a heavily overloaded confusing term that has long been synonymous with software containerization.

They try to explain [what containers are](https://www.docker.com/resources/what-container/) and they have no doubt played a huge role in defining them.

Docker the company has provided every containerization component imaginable and they all fall under the "Docker" term umbrella. But now that others offer alternative components it is good to have names for those types of components.

Even Docker's own documentation appears to contradict itself sometimes. The boundaries of declared by the their definitions seem to migrate.

### Terminology

Existing glossaries leave me wanting better organization or focus on fundamentals.

+ [Redhat's Glossary](https://developers.redhat.com/blog/2018/02/22/container-terminology-practical-introduction#) (generic with good long explanations)
+ [Docker's Glossary](https://docs.docker.com/reference/glossary/) (breaks Docker into components, but very Docker specific)
+ [Kubernetes Glossary](https://kubernetes.io/docs/reference/glossary/?fundamental=true) (generic containerization terms, with a bunch of Kubernetes specifics)

There seems to be many pieces of software that act as both an engine and a runtime. Some of them also create virtual machines. So be wary of relying too much on any definition strictly.

#### Succint Glossary

These are the most important terms that I have gleaned from documentation and other glossaries.

container - software from a container image running in a process with a limited and isolated environment
container image - file archive that contains other files required for a piece of sofware
container registry - a place to store, look up, and retrieve container iamges
container engine - software that manages container images and containers often as a server for a client
container runtime - software component that container engines delegate container running to
container host - machine with OS, virtual machine with OS, or another container where the conainers will run
container orchestrator - software systems that run software in containers often distrubted across multiple hosts


#### Deeper Understanding of Containers

What resources can a container access? Obviously any running program needs CPU time and memory, but they can also be allowd to access storage and network. 

[Containers from Scratch](https://www.youtube.com/watch?v=8fi7uSYlOdc)
[Build your own Container Runtime](https://www.youtube.com/watch?v=JOsWB50LmwQ)

Apparently container runtimes can depend on or be composed of other container runtimes.

[Exmaple showing runc as part of containerd](https://www.docker.com/blog/containerd-vs-docker/)


### Local Machine Usage

These tools make it easy to run containers on your local machine and make it easy to use some of the same tools that you would use on remote machine clusters. They are good for learning, practicing, and developing.

Since all container technology as defined by the [Open Container Initiative](https://opencontainers.org/) (part of Linux Foundation) relies on Linux, virtual machines are often required on non-Linux OSes. These tools either provide or require the creation of Linux VMs which make it possible to run containers on non-Linux OSes.

#### Docker Desktop

Docker Desktop was free for years and allowed all things provide by Docker to work your local machine, but it is no longer free for all uses.

#### Colima

[Colima](https://github.com/abiosoft/colima) lets you easily run containers on macOS by creating Linux virtual machines.

Use `colima start` to create a VM with a container engine and runtime.
Use `colima status` to see the current state.

#### Minikube

Minikube makes it easy to run Kubernetes on your local machine, but the [Minikube installation instructions](https://minikube.sigs.k8s.io/docs/start/) say it requies a "container or virtual machine manager" which they apparently call "drivers". They point out several utilities for fulfilling the driver requirement that all appear to have the ability to create virtual machines. Installing either Docker Desktop or Colima are two easy ways to make it work.

Use `minikube start` to create a Kubernetes cluster.
`minikube start --driver=docker` allows amd64 images to run on arm64 machines, but it requires Docker Desktop to be installed and running. It will be the default driver if Docker Desktop is running, otherwise `qemu2` is the default which apparently comes with the Minikube (at least when installed by Homebrew).
Use `minikube status` to see the current state.

#### Comparing and Switching

These features allow you to create, view, and switch between multiple instances.

+ Create multiple instances of Minikube or Colima with the `-p, --profile` option
  + `minikube profile list` and `colima list` to see the profiles
+ Docker CLI uses environment variables to determine which server to issue commands to.You can to use `eval $(minikube -p minikube docker-env)` to set up your shell so that `docker` CLI commands will use the server and runtime created by Minikube.
+ `docker context ls` lets you see and use different container engines through the same `docker` CLI 
+ `kubectl config get-contexts` shows which clusters exist and which one it is using


#### 


`kubeadm` is the way to create "real" clusters.
Can it be used locally?


What examples of runtimes, engines,

nice diagram of runtime / OS but doesn't explain VMs: https://www.docker.com/blog/containerd-vs-docker/

Incus docs provide informationa about system container vs app container vs vm: https://linuxcontainers.org/incus/docs/main/explanation/containers_and_vms/


If you like to regress to childhood and imagine software as wooden blocks stacked on top of each other, like I do, then here are some pictures.

### list of minikube drivers to investigate
from: https://minikube.sigs.k8s.io/docs/start/?arch=%2Fmacos%2Farm64%2Fstable%2Fbinary+download

Docker, QEMU, Hyperkit, Hyper-V, KVM, Parallels, Podman, VirtualBox, or VMware Fusion/Workstation
